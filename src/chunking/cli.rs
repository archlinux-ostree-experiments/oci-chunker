use std::fs::File;

use camino::Utf8PathBuf;
use clap::{Args, ValueEnum};

use crate::{
    chunking::{Chunker, ostreext::OstreeExtChunker},
    pkgdb::PackageIndex,
};

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub(crate) enum ChunkingStrategy {
    /// Let OstreeExt do all the work using its internal algorithm
    OstreeExt,
}

impl ChunkingStrategy {
    pub fn get_chunker(&self) -> Box<dyn Chunker> {
        match self {
            ChunkingStrategy::OstreeExt => Box::new(OstreeExtChunker::new()),
        }
    }
}

/// Generate a chunked OCI image from a package index and an OSTree commit.
#[derive(Debug, Args)]
pub(crate) struct GenerateChunkedOCIOpts {
    #[clap(
        long,
        required = true,
        help = "Path to a package index file, as generated by `build-package-index`"
    )]
    pub package_index: Utf8PathBuf,
    #[clap(long, required = true)]
    pub ostree_repo: Utf8PathBuf,
    #[clap(long, required = true)]
    pub ostree_commit: String,
    #[clap(
        long,
        required = true,
        help = "Output specification for the generated container image"
    )]
    pub output: String,
    #[clap(long, required = false, default_value = "64")]
    pub max_layers: usize,
    #[clap(long, required = false, default_value = "ostree-ext")]
    pub chunking_strategy: ChunkingStrategy,
}

impl GenerateChunkedOCIOpts {
    pub(crate) fn run(self) -> Result<(), anyhow::Error> {
        let package_index =
            serde_json::from_reader::<_, Vec<PackageIndex>>(File::open(&self.package_index)?)?;
        let mut chunker = self.chunking_strategy.get_chunker();
        let meta = chunker.chunk(&package_index, self.max_layers, &self.ostree_repo, &self.ostree_commit)?;
        Ok(())
    }
}
