use std::{fs::File, num::NonZero};

use camino::Utf8PathBuf;
use clap::{Args, ValueEnum};

use crate::{
    chunking::{Chunker, ostreext::OstreeExtChunker},
    pkgdb::PackageIndex,
    rpm_ostree::{ContainerEncapsulateOpts, container_encapsulate},
};

const MAX_LAYERS_DEFAULT: NonZero<u32> = NonZero::new(64).unwrap();

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub(crate) enum ChunkingStrategy {
    /// Create one chunk per package and use the native algorithm of ostree-ext
    OstreeExt,
}

impl ChunkingStrategy {
    pub fn get_chunker(&self) -> Box<dyn Chunker> {
        match self {
            ChunkingStrategy::OstreeExt => Box::new(OstreeExtChunker::new()),
        }
    }
}

/// Generate a chunked OCI image from a package index and an OSTree commit.
#[derive(Debug, Args)]
pub(crate) struct GenerateChunkedOCIOpts {
    #[clap(
        long,
        required = true,
        help = "Path to a package index file, as generated by `build-package-index`"
    )]
    pub package_index: Utf8PathBuf,
    #[clap(long, required = false, default_value = "ostree-ext")]
    pub chunking_strategy: ChunkingStrategy,

    #[command(flatten)]
    pub ostree_encapsulate: ContainerEncapsulateOpts,
}

impl GenerateChunkedOCIOpts {
    pub(crate) fn run(mut self) -> Result<(), anyhow::Error> {
        let package_index =
            serde_json::from_reader::<_, Vec<PackageIndex>>(File::open(&self.package_index)?)?;
        let mut chunker = self.chunking_strategy.get_chunker();
        let max_layers = self
            .ostree_encapsulate
            .max_layers
            .unwrap_or(MAX_LAYERS_DEFAULT);
        let meta = chunker.chunk(
            &package_index,
            max_layers,
            &self.ostree_encapsulate.repo,
            &self.ostree_encapsulate.ostree_ref,
        )?;
        self.ostree_encapsulate.max_layers = Some(max_layers);
        container_encapsulate(self.ostree_encapsulate, &meta)
    }
}
