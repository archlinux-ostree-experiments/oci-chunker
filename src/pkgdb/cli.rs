use std::{collections::HashMap, fs::File};

use camino::{Utf8Path, Utf8PathBuf};
use chrono::Datelike;
use clap::{Args, ValueEnum};

#[cfg(feature = "archlinux")]
use crate::pkgdb::archlinux::AlpmDb;
use crate::{
    pkgdb::{
        PackageDatabase, PackageDatabaseWithDefaultPath, PackageIndex,
        postprocessing::Postprocessing, rpm::RpmDb,
    },
    rpm_ostree::run_with_mount,
    util::get_buildtime,
};

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub(crate) enum PackageBackend {
    Rpm,
    #[cfg(feature = "archlinux")]
    Alpm,
}

impl PackageBackend {
    pub(crate) fn get_backend(
        &self,
        sysroot: &Utf8Path,
        pkgdb_path: Option<&Utf8Path>,
    ) -> Result<Box<dyn PackageDatabase>, anyhow::Error> {
        match self {
            PackageBackend::Rpm => Ok(Box::new(RpmDb::new(
                sysroot.join(pkgdb_path.unwrap_or(RpmDb::DEFAULT_PATH.as_ref())),
            ))),
            #[cfg(feature = "archlinux")]
            PackageBackend::Alpm => Ok(Box::new(AlpmDb::new(
                sysroot,
                pkgdb_path.unwrap_or(AlpmDb::DEFAULT_PATH.as_ref()),
            )?)),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub(crate) enum ChangelogSource {
    PackageDatabase,
    PreviousIndex,
    Initialize,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub(crate) enum ChangelogResolution {
    Daily,
    Weekly,
    Monthly,
    Exact,
}

impl ChangelogResolution {
    pub(crate) fn normalize(&self, timestamp: u64) -> Result<u64, anyhow::Error> {
        // Safety: This will not fail for sane unix timestamps (which we generate ourselves or expect to be imported from a JSON docuemnt generated by ourselves).
        // Let's see how this works out in practice using package manager outputs.
        let datetime =
            chrono::DateTime::from_timestamp(i64::try_from(timestamp).unwrap(), 0).unwrap();
        let constant_time = chrono::NaiveTime::from_hms_opt(1, 0, 0).unwrap();
        // Safety: We expect to build _Linux_ distribution images, so naturally we do not expect the need to handle dates prior to 1970.
        let ts = match self {
            ChangelogResolution::Daily => u64::try_from(
                datetime
                    .with_time(constant_time)
                    .earliest()
                    .ok_or(anyhow::Error::msg(
                        "Could not construct a valid timestamp (hms)",
                    ))?
                    .timestamp(),
            )
            .unwrap(),
            ChangelogResolution::Weekly => {
                // Fortunately, as the resolution must stay constant anyway, this doesn't have to be correct, but only consistent and reproducible
                // TODO: This won't work for ISO8601 "leap weeks", so there cannot be a distict release in such a week.
                let (year, week) = (datetime.iso_week().year(), datetime.iso_week().week());
                u64::try_from(
                    datetime
                        .with_year(year)
                        .ok_or(anyhow::Error::msg(
                            "Could not construct a valid timestamp (invalid year)",
                        ))?
                        .with_ordinal(week.max(52) * 7)
                        .ok_or(anyhow::Error::msg(
                            "Could not construct a valid timestamp (day of year)",
                        ))?
                        .with_time(constant_time)
                        .earliest()
                        .ok_or(anyhow::Error::msg(
                            "Could not construct a valid timestamp (hms)",
                        ))?
                        .timestamp(),
                )
                .unwrap()
            }
            ChangelogResolution::Monthly => u64::try_from(
                datetime
                    .with_day(1)
                    .ok_or(anyhow::Error::msg(
                        "Could not construct a valid timestamp (invalid year)",
                    ))?
                    .with_time(constant_time)
                    .earliest()
                    .ok_or(anyhow::Error::msg(
                        "Could not construct a valid timestamp (hms)",
                    ))?
                    .timestamp(),
            )
            .unwrap(),
            ChangelogResolution::Exact => timestamp,
        };
        Ok(ts)
    }
}

/// Generate a Package Index from an input rootfs or container image.
#[derive(Args, Debug)]
pub(crate) struct BuildPackageIndexOpts {
    #[clap(long, required = false, default_value = "rpm")]
    pub backend: PackageBackend,
    #[clap(
        long,
        required_unless_present = "image",
        help = "path to a rootfs containing the package manager database"
    )]
    pub sysroot: Option<Utf8PathBuf>,
    #[clap(
        long,
        required_unless_present = "sysroot",
        help = "path to a container image in container-storage containing the package manager database"
    )]
    pub image: Option<String>,
    #[clap(
        long,
        required = false,
        help = "path to the package manager database inside the image/rootfs"
    )]
    pub pkgdb_path: Option<Utf8PathBuf>,
    #[clap(long, required = false, default_value = "previous-index")]
    pub changelog_source: ChangelogSource,
    #[clap(long, required = false, default_value = "weekly")]
    pub changelog_resolution: ChangelogResolution,
    #[clap(long, required = false)]
    pub previous_package_index: Option<Utf8PathBuf>,
    #[clap(long, required = false)]
    pub output_package_index: Option<Utf8PathBuf>,
    #[clap(
        long,
        required = false,
        help = "TOML file with postprocessing information (add and merge packages)"
    )]
    pub postprocessing: Option<Utf8PathBuf>,
    #[clap(long, required = false)]
    pub output_ostree_ext_metadata: Option<Utf8PathBuf>,
}

impl BuildPackageIndexOpts {
    pub(crate) fn run(&self) -> Result<(), anyhow::Error> {
        run_with_mount(
            |dir| self.run_with_sysroot(dir),
            self.sysroot.clone(),
            self.image.clone(),
        )
    }

    fn run_with_sysroot(&self, sysroot: &Utf8Path) -> Result<(), anyhow::Error> {
        tracing::trace!("Running with sysroot {:?}", sysroot);
        // We use the current build time as an ID for the changelog, if it is not populated from the package database.
        let build_time = get_buildtime();
        let change_id = self.changelog_resolution.normalize(build_time)?;
        let backend = self
            .backend
            .get_backend(sysroot, self.pkgdb_path.as_ref().map(|p| p.as_ref()))?;
        let packages = backend.get_packages()?;
        tracing::debug!("Obtained {} packages from database", packages.len());
        let packages = match self.postprocessing {
            Some(ref postprocessing_path) => {
                let postprocessing = Postprocessing::new_from_toml(postprocessing_path)?;
                postprocessing.apply(packages)?
            }
            None => packages,
        };
        tracing::debug!("There are {} packages after postprocessing", packages.len());
        let packages = match self.changelog_source {
            ChangelogSource::PackageDatabase => packages
                .into_iter()
                .map(|package| -> Result<PackageIndex, anyhow::Error> {
                    let changelog = backend.get_changes(&package)?;
                    let skip = if changelog.len() <= super::MAXIMUM_CHANGES {
                        0
                    } else {
                        changelog.len() - super::MAXIMUM_CHANGES
                    };
                    let changelog = changelog
                        .into_iter()
                        .skip(skip)
                        .take(super::MAXIMUM_CHANGES)
                        .map(|change| self.changelog_resolution.normalize(change))
                        .collect::<Result<Vec<u64>, _>>()?;
                    Ok(PackageIndex::new(package, changelog))
                })
                .collect::<Result<Vec<PackageIndex>, anyhow::Error>>()?,
            ChangelogSource::PreviousIndex => {
                let previous_package_metadata = if let Some(previous_package_metadata) =
                    &self.previous_package_index
                {
                    serde_json::from_reader::<_, Vec<PackageIndex>>(File::open(
                        previous_package_metadata,
                    )?)?
                } else {
                    anyhow::bail!(
                        "Obtaining changelog from previous index file requested, but no previous index file was specified"
                    );
                };
                let mut previous_package_metadata = previous_package_metadata
                    .into_iter()
                    .map(|package| (package.package.name.clone(), package))
                    .collect::<HashMap<String, PackageIndex>>();
                packages
                    .into_iter()
                    .map(|package| {
                        let previous_version = previous_package_metadata.remove(&package.name);
                        match previous_version {
                            Some(metadata) => PackageIndex::update_from_previous_index(
                                package, metadata, change_id,
                            ),
                            None => PackageIndex::initialize(package, change_id),
                        }
                    })
                    .collect()
            }
            ChangelogSource::Initialize => packages
                .into_iter()
                .map(|package| PackageIndex::initialize(package, change_id))
                .collect(),
        };
        tracing::trace!("Changelog created");
        if let Some(output_package_index) = &self.output_package_index {
            serde_json::to_writer(File::create_new(output_package_index)?, &packages)?;
            tracing::trace!("Package Index written to disk");
        }
        Ok(())
    }
}
